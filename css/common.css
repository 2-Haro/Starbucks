/* COMMON */

body {
  color: #333; /* 글자색: 어두운 회색(#333) */
  font-size: 16px; /* 글자 크기: 16px */
  font-weight: 400; /* 글자 두께: 400 */
  line-height: 1.4; /* 행간: 1.4 */
  font-family: 'Nanum Gothic', sans-serif; /* 폰트: 나눔 고딕 */
  /* body 태그 부분의 글자색은 회색, 글자 크기는 16px, 글자 두께는 400, 행간 1.4, 나눔 고딕 폰트 적용. 문자와 글자는 CSS 상속의 개념을 통해서 자식 요소와 하위 요소로 상속 */
}

img {
  display: block; /* img 요소는 기본적으로 인라인 요소이지만, img 요소를 화면을 구성하는 하나의 레이아웃(블록 요소)으로 활용 -> 로고 밑 공간이 시라진다 */
}

a { /* text-decoration: none을 통해서 a 태그에 기본적으로 선을 사용하지 않는다는 것을 명시 */
  text-decoration: none;
}

.inner { /* 'inner'라는 class를 가지고 있는 모든 요소 */
  width: 1100px; /* 너비: 1100px */
  margin: 0 auto; /* 외부 여백(margin)속성을 위아래는 0, 좌우는 브라우저가 자동으로 계산하도록 auto로 설정 */ /* width와 margin 속성으로 인해서 header 영역의 내용을 가운데 정렬 */
  position: relative; /* 자식 요소의 position 값을 추가하는데 문제가 생기지 않도록 부모 요소 자신을 기준으로 하는 relative 값을 부여(position이 없었던 값을 추가하는 것이므로) */
}

.btn { /* 'btn'이라는 class를 가지고 있는 모든 요소 */ /* class 선택자 1개 -> 우선순위 점수 10점 */
  width: 130px; /* 너비: 130px */
  padding: 10px; /* 내부 여백: 10px */
  border: 2px solid #333; /* 테두리선: 2px, 실선, 어두운 회색(#333) */
  border-radius: 4px; /* btn 요소의 모서리를 5px 만큼 둥글게 깎는다 */ 
  color: #333; /* 글자색: 어두운 회색(#333) */
  font-size: 16px; /* 글자 크기: 16px */
  font-weight: 700; /* 글자 두께: 700 */
  text-align: center; /* 글자 정렬: 가운데 */
  cursor: pointer; /* 마우스 포인터를 요소에 올렸을 때 화살표 모양에서 손가락 모양으로 바뀌도록 한다 */
  box-sizing: border-box; /* 요소의 내용 + padding + border로 크기 계산 */
  display: block; /* a 태그나 span 태그 부분에 btn이라는 class를 부여했을 때도 정상적으로 나타나도록 함 */
  transition: .4s; /* 전환 효과: 0.4초 */ 
}
.btn:hover { /* 'btn'이라는 class를 가진 선택자에 가상 클래스 선택자 hover를 추가함으로써 각각의 'btn' 선택자 부분에 마우스를 올리면 선택 */
  background-color: #333; /* 배경 색상: 어두운 회색(#333) */
  color: #FFF; /* 글자색: 흰색(#FFF) */
}
.btn.btn--reverse { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 reverse인 특정 요소 */ /* class 선택자 2개 -> 우선순위 점수 20점 */
  background-color: #333; /* 배경 색상: 어두운 회색(#333) */
  color: #FFF; /* 글자색: 흰색(#FFF) */
}
.btn.btn--reverse:hover { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 reverse인 특정 요소에 가상 클래스 선택자 hover를 추가함으로써 각각의 'btn' 부분의 상태가 reverse인 요소에 마우스를 올리면 선택 */ /* class 선택자 2개 + 가상 class 선택자 1개 -> 우선순위 점수 30점 */
  background-color: transparent; /* 배경 색상: 투명 */
  color: #333; /* 글자색: 어두운 회색(#333) */
}
.btn.btn--brown { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 brown인 특정 요소 */
  color: #592b18; /* 글자색: 갈색(#592b18) */
  border-color: #592B18; /* 테두리 색상: 갈색(#592b18) */

}
.btn.btn--brown:hover { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 brown인 특정 요소에 가상 클래스 선택자 hover를 추가함으로써 각각의 'btn' 부분의 상태가 brown인 요소에 마우스를 올리면 선택 */
  color: #FFF; /* 글자색: 흰색(#FFF) */
  background-color: #592B18; /* 배경 색상: 갈색(#592b18) */
}
.btn.btn--gold { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 gold인 특정 요소 */
  color: #D9AA8A; /* 글자색: 금색(#D9AA8A) */
  border-color: #D9AA8A; /* 테두리 색상: 금색(#D9AA8A) */
}
.btn.btn--gold:hover { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 gold인 특정 요소에 가상 클래스 선택자 hover를 추가함으로써 각각의 'btn' 부분의 상태가 gold인 요소에 마우스를 올리면 선택 */
  color: #FFF; /* 글자색: 흰색(#FFF) */
  background-color: #D9AA8A; /* 배경 색상: 금색(#D9AA8A) */
}
.btn.btn--white { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 white인 특정 요소 */
  color: #FFF; /* 글자색: 흰색(#FFF) */
  border-color: #FFFF; /* 테두리 색상: 흰색(#FFF)) */
}
.btn.btn--white:hover { /* 'btn'이라는 class를 가진 선택자 부분의 상태가 white인 특정 요소에 가상 클래스 선택자 hover를 추가함으로써 각각의 'btn' 부분의 상태가 white인 요소에 마우스를 올리면 선택 */
  color: #333; /* 글자색: 어두운 회색(#333) */
  background-color: #FFF; /* 배경 색상: 흰색(#FFF) */
}

.back-to-position { /* back-to-position'이라는 class를 가진 선택자 */
  opacity: 0; 
  transition: 1s;
}
.back-to-position.to-right { /* class 선택자 'back-to-position & to-right'(일치 선택자) */
  transform: translateX(-150px); /* 변환 효과인 translateX 속성으로 수평(X축)으로 -150px 만큼의 지점으로 이동(왼쪽으로 이동시켜 놓는다) */
}
.back-to-position.to-left { /* class 선택자 'back-to-position & to-left'(일치 선택자) */
  transform: translateX(150px); /* 변환 효과인 translateX 속성으로 수평(X축)으로 150px 만큼의 지점으로 이동(오른쪽으로 이동시켜 놓는다) */
}
.show .back-to-position { /* class 선택자 'show'의 하위 class 선택자 'back-to-position' 선택자 */
  opacity: 1;
  transform: translateX(0); /* 변환 효과인 translateX 속성으로 원래의 지점으로 복귀 */
}
.show .back-to-position.delay-0 { /* class 선택자 'show'의 하위 class 선택자 'back-to-position delay-0' 선택자(일치 선택자) */
  transition-delay: 0s; /* 전환 효과를 통해서 요소의 전후 상태를 자연스럽게 처리할 때의 지연시간 설정 */
}
.show .back-to-position.delay-1 { /* class 선택자 'show'의 하위 class 선택자 'back-to-position delay-1' 선택자(일치 선택자) */
  transition-delay: .3s; /* 전환 효과를 통해서 요소의 전후 상태를 자연스럽게 처리할 때의 지연시간 설정 */
}
.show .back-to-position.delay-2 { /* class 선택자 'show'의 하위 class 선택자 'back-to-position delay-2' 선택자(일치 선택자) */
  transition-delay: .6s; /* 전환 효과를 통해서 요소의 전후 상태를 자연스럽게 처리할 때의 지연시간 설정 */
}
.show .back-to-position.delay-3 { /* class 선택자 'show'의 하위 class 선택자 'back-to-position delay-3' 선택자(일치 선택자) */
  transition-delay: .9s; /* 전환 효과를 통해서 요소의 전후 상태를 자연스럽게 처리할 때의 지연시간 설정 */
}
/* 0.3초의 간격으로 화면에 나타나도록 설정 */

/* HEADER */

header { /* header 선택자 */
  width: 100%;
  position: fixed; /* 뷰포트를 기준으로 배치 */
  top: 0; /* 뷰포트를 기준으로 100%를 사용하고, 위에서부터 0px 지점에 배치 */
  background-color: #F6F5F0;
  border-bottom: 1px solid #c8c8c8; /* 아래 테두리선: 1px, soild, #c8c8c8 */
  z-index: 9; /* z-index 값을 9로 설정해서, 다른 section보다 더 위에 쌓이도록 설정 */
}
header > .inner { /* header 선택자의 자식 class 선택자 inner 선택자 */
  height: 120px; /* 높이: 120px */
  /* width: 1100px; -> 너비: 1100px
  margin: 0 auto; -> 외부 여백(margin)속성을 위아래는 0, 좌우는 브라우저가 자동으로 계산하도록 auto로 설정 / width와 margin 속성으로 인해서 header 영역의 내용을 가운데 정렬
  position: relative; -> 자식 요소의 position 값을 추가하는데 문제가 생기지 않도록 부모 요소 자신을 기준으로 하는 relative 값을 부여
  COMMON에서 'inner'라는 class를 가지고 있는 모든 요소에 대해서 정의한다 */
}
header .logo { /* header 선택자의 하위 class 선택자 logo 선택자(a 태그 내) */
  height: 75px; /* 높이를 로고의 실제 높이 값인 75px로 명시, 실제 높이 값이 있어야 가운데 배치 가능(브라우저가 margin을 자동으로 계산하도록 하기 위해서 브라우저에게 높이 값을 명시) -> 너비도 동일 */
  position: absolute; /* position: absoulute 속성을 이용해서 부모 요소 기준으로 배치 */
  top: 0; /* 위에서부터 0px 지점, 수직의 끝 점  */
  bottom: 0; /* 아래에서부터 0px 지점, 수직의 끝 점 */
  left: 0; /* 왼쪽에서부터 0px 지점 */
  /* left: 0; right: 0; width: ; 지정해주면 수평으로 가운데 배치 가능 */
  margin: auto; /* 외부 여백(margin)속성을 브라우저가 자동으로 계산하도록 auto로 설정 */ /* top, bottom, height, margin 속성으로 인해서 logo가 header 영역 안에서 수직 가운데 배치 */
}
header .sub-menu { /* header 선택자의 하위 class 선택자 sub-menu 선택자(ul 태그와 search 포함) */
  position: absolute; /* position: absoulute 속성을 이용해서 부모 요소 기준으로 배치 */
  top: 10px; /* 위에서부터 10px 지점 */
  right: 0; /* 오른쪽에서부터 0px 지점 */
  display: flex; /* menu 부분 우측에 search 부분 수평으로 정렬 */
}
header .sub-menu ul.menu { /* header 선택자의 하위 class 선택자 sub-menu 선택자의 하위 태그인 ul 태그의 하위 class 선택자 menu 선택자 */
  font-family: Arial, sans-serif; /* menu의 글꼴을 Arial로 지정, 사용자의 사용 환경에서 적용 불가능할 때를 대비해서 일반 고딕체 계열 명시 */
  display: flex; /* display: flex 속성을 통해 수직으로 쌓여 있는 요소들을 수평 정렬되도록 변경 */
}
header .sub-menu ul.menu li { /* header 선택자의 하위 class 선택자 sub-menu 선택자의 하위 태그인 ul 태그의 하위 class 선택자 menu 선택자의 하위 태그인 li 태그 */
  position: relative; /* 자식 요소의 position 값을 추가하는데 문제가 생기지 않도록 부모 요소 자신을 기준으로 하는 relative 값을 부여 */
}
header .sub-menu ul.menu li::before { /* 가상 요소 선택자 before를 통해서 선택자 'li' 태그의 내부의 앞쪽에 내용을 삽입 */
  content: ""; /* 글자를 넣을 것이 아니라면 content 속성은 비워둘 수 있지만, content 요소가 없으면 가상 요소 선택자 before이 만들어지지 않기 때문에 삭제 X */
  width: 1px; /* 너비: 1px */
  height: 12px; /* 높이: 12px */
  background-color: #E5E5E5; /* 구분선 색상: 밝은 회색 */
  position: absolute; /* position: absoulute 속성을 이용해서 부모 요소 기준으로 배치 */ /* position: absolute 속성을 사용하면 display 값이 자동으로 블록으로 변한다  -> 가로, 세로 값을 가질 수 있다 */
  top: 0;
  bottom: 0; /* 위에서 0px, 아래에서 0px 지점으로 배치할 기준을 맞춘다 */
  margin: auto; /* 외부 여백(margin)속성을 브라우저가 자동으로 계산하도록 auto로 설정해서 수직 가운데에 맞춘다 */
}
header .sub-menu ul.menu li:first-child::before { /* 가상 요소 선택자 before 앞에 가상 클래스 선택자 first-child를 추가함으로써 여러 li 태그들 중 첫번째 li 태그의 가상 요소 선택자 before 부분 선택 */
  display: none; /* display: none을 입력하면 해당 요소가 보이지 않음 */
}
header .sub-menu ul.menu li a { /* header 선택자의 하위 class 선택자 sub-menu 선택자의 하위 태그인 ul 태그의 하위 class 선택자 menu 선택자의 하위 태그인 li 테그의 하위 태그인 a 태그 */
  font-size: 12px;
  /* 링크 영역을 만들 때는 사용자가 정확한 영역을 클릭할 수 있도록 여러가지 UI 방식들을 제공 */
  padding: 11px 16px; /* 위아래 11px, 좌우 16px의 여백 추가 */
  display: block; /* a 태그는 원래 인라인 요소이기 때문에 margin과 padding을 가질 수 없지만, display: block 속성을 통해 a 태그를 블록 요소로 만들어줘서 가질 수 있도록 한다 */
  color: #656565; /* 글자색을 파란색 또는 보라색에서 회색으로 바꿔준다 */
}
header .sub-menu ul.menu li a:hover { /* a 태그에 가상 클래스 선택자 hover를 추가함으로써 각각의 a 태그 부분에 마우스를 올리면 선택 */
  color: #000; /* 메뉴에 마우스를 올리면 글자가 검정색으로 변한다 */
}
header .sub-menu .search { /* header 선택자의 하위 class 선택자 sub-menu 선택자의 하위 class 선택자 search 선택자 */
  height: 34px; /* 높이: 34px */ 
  position: relative; /* 자식 요소의 position 값을 추가하는데 문제가 생기지 않도록 부모 요소 자신을 기준으로 하는 relative 값을 부여 */
}
header .sub-menu .search input { /* header 선택자의 하위 class 선택자 sub-menu 선택자의 하위 class 선택자 search 선택자의 하위 태그인 input 선택자 */
  width: 36px; /* 너비: 36px */
  height: 34px; /* 높이: 34px */
  padding: 4px 10px; /* 내부 여백: 위아래 4px 좌우 10px */
  border: 1px soild #ccc; /* 테두리 선: 1px, soild, 밝은 회색 */
  box-sizing: border-box; /* 요소의 내용 + padding + border로 크기 계산 */
  border-radius: 5px; /* input 요소의 모서리를 5px 만큼 둥글게 깎는다 */
  outline: none; /* input 요소를 선택했을 때 생기는 파란색 선(outline)이 보이지 않게 한다 */
  background-color: #fff; /* 배경 색상: 흰색 */
  color: #777; /* 글자 색상: 회색 */
  font-size: 12px; /* 글자 크기: 12px */
  transition: width .4s; /* 너비 전환 효과: 0.4초 */
}
header .sub-menu .search input:focus { /* input 태그 선택자에 가상 클래스 선택자 focus를 추가함으로써 선택자 요소가 focus 되면 선택한다 */
  width: 190px; /* 너비: 190px */
  border-color: #669900; /* 테두리 선 색상: 초록색 */
}
header .sub-menu .search .material-icons { /* header 선택자의 하위 class 선택자 sub-menu 선택자의 하위 class 선택자 search 선택자의 하위 class 선택자 material-icons 선택자 */
  height: 24px; /* 높이를 material-icon의 실제 높이 값인 24px로 명시, 실제 높이 값이 있어야 가운데 배치 가능 */
  position: absolute; /* 부모 요소 기준으로 배치 */
  top: 0;
  bottom: 0; /* 위에서 0px, 아래에서 0px 지점으로 배치할 기준을 맞춘다 */
  right: 5px; /* 부모 요소 기준으로 오른쪽에서 5px 지점에 배치 */
  margin: auto; /* 외부 여백(margin)속성을 브라우저가 자동으로 계산하도록 auto로 설정해서 수직 가운데에 맞춘다  -> 위아래 0px 지점에 배치하고 height 값이 있다면 margin: auto를 추기해서 수직 가운데 배치 가능 */
  transition: .4s; /* 전환 효과: 0.4초 */
}
header .sub-menu .search.focused .material-icons { /* Javascript로부터 추가되고 삭제되는 focused(search와 일치 선택자로 추가)선택자 */
  opacity: 0; /* search 부분이 focused가 된 상태에서는 material-icon이 보이지 않게 하기 위해 투명도를 0으로 설정 */
}
header .main-menu { /* header 선택자의 하위 class 선택자 main-menu 선택자 */
  position: absolute; /* 부모 요소 기준으로 배치 */
  bottom: 0;
  right: 0; /* 아래에서 0px, 오른쪽에서 0px 지점에 배치 */
  z-index: 1; /* 요소의 쌓임 순서를 제어해서 제일 위쪽에 나타나도록 한다 */
  display: flex; /* display: flex를 통해 각각의 menu들이 수평으로 정렬되도록 한다 */
}
header .main-menu .item .item__name { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__name 선택자 */
  padding: 10px 20px 34px 20px; /* 내부 여백: 위 10px, 오른쪽 20px, 아래 34px, 왼쪽 20px */
  font-family: Arial, sans-serif; /* main-menu의 글꼴을 Arial로 지정, 사용자의 사용 환경에서 적용 불가능할 때를 대비해서 일반 고딕체 계열 명시 */
  font-size: 13px; /* 글자 크기: 13px */
}
header .main-menu .item:hover .item__name { /* 가상 클래스 선택자 hover를 item에 붙여서 마우스를 올렸을 때 item__name과 item___contents에 모두 영향을 준다 */
  background-color: #2c2a29;
  color: #669900;
  border-radius: 6px 6px 0 0; /* item_name 요소의 좌측, 우측 상단의 모서리를 6px 만큼 둥글게 깎는다 */
}
header .main-menu .item .item__contents { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자 */
  width: 100%; /* 너비의 상대적 백분율을 100%로 설정) */
  position: fixed; /* 뷰포트를 기준으로 배치 */
  left: 0; /* top이나 bottom 속성을 사용하지 않아 수직 위치 값이 없다면, 요소의 원래 위치를 그대로 사용한다 */ /* 만약 position:absolute를 사용했다면, 부모 요소를 기준으로 하므로 화면의 뷰포트 좌우 끝까지 늘어날 수 없게 된다 */
  display: none; /* 마우스를 올리지 않았을 때 화면에서 숨긴다 */
}
header .main-menu .item:hover .item__contents { /* 가상 클래스 선택자 hover를 item에 붙여서 마우스를 올렸을 때 item__name과 item___contents에 모두 영향을 준다 */
  display: block; /* 마우스를 올렸을 때 화면에 출력될 수 있도록 한다 */
}
header .main-menu .item .item__contents .contents__menu { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__menu 선택자 */
  background-color: #2c2a29;
}
header .main-menu .item .item__contents .contents__menu > ul { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__menu 선택자의 자식 선택자 ul 태그(contents__menu내에는 ul 태그가 여러 개 있기 때문에 자식 선택자로 명시하지 않으면 하위 선택자가 되어서 contents__meunu 내 모든 ul 태그에 영향을 미침) */
  display: flex; /* display: flex를 통해 각각의 menu들이 수평으로 정렬되도록 한다 */
  padding: 20px 0; /* 내부 여백: 위아래 20px */
}
header .main-menu .item .item__contents .contents__menu > ul > li { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__menu 선택자의 자식 선택자 ul 태그의 자식 선택자 li 태그 */
  width: 220px; /* 너비: 220px */
}
header .main-menu .item .item__contents .contents__menu > ul > li h4 { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__menu 선택자의 자식 선택자 ul 태그의 자식 선택자 li 태그의 하위 선택자 h4 태그 */
  padding: 3px 0 12px 0; /* 내부 여백: 위 3px, 아래 12px */
  font-size: 14px; /* 글자 크기: 14px */
  color: #fff;
}
header .main-menu .item .item__contents .contents__menu > ul > li ul li { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__menu 선택자의 자식 선택자 ul 태그의 자식 선택자 li 태그의 하위 선택자 ul 태그의 하위 선택자 li 태그 */
  padding: 5px 0; /* 내부 여백: 위아래 5px */
  font-size: 12px; /* 글자 크기: 12px */
  color: #999;
  cursor: pointer; /* 마우스 포인터를 요소에 올렸을 때 화살표 모양에서 손가락 모양으로 바뀌도록 한다 */
}
header .main-menu .item .item__contents .contents__menu > ul > li ul li:hover { /* li 태그 선택자에 가상 클래스 선택자 hover를 추가함으로써 각각의 li 태그 부분에 마우스를 올리면 선택 */
  color: #669900;
}
header .main-menu .item .item__contents .contents__texture { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__texture 선택자 */
  padding: 26px 0; /* 내부 여백: 위아래 26px */
  font-size: 12px; /* 글자 크기: 12px */
  background-image: url("../images/main_menu_pattern.jpg"); /* 요소의 배경으로 이미지를 사용하기 위해 background-image와 url 함수를 사용해서 해당 이미지가 있는 경로를 입력 */
}
header .main-menu .item .item__contents .contents__texture h4 { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__texture 선택자의 하위 선택자 h4 태그 */
  color: #999;
  font-weight: 700; /* 글자의 두께: 700 */
}
header .main-menu .item .item__contents .contents__texture p { /* header 선택자의 하위 class 선택자 main-menu 선택자의 하위 class 선택자 item 선택자의 하위 class 선택자 item__contents 선택자의 하위 class 선택자 contents__texture 선택자의 하위 선택자 p 태그 */
  color: #669900;
  margin: 4px 0 14px; /* 외부 여백을 위 4px, 아래 14px로 설정 */
}
header .badges { /* header 선택자의 하위 class 선택자 badges 선택자 */
  position: absolute; /* position: absoulute 속성을 이용해서 부모 요소(header)기준으로 배치 */
  top: 132px;
  right: 12px; /* 위에서 132px, 오른쪽에서 12px 지점에 배치 */
}
header .badges .badge { /* header 선택자의 하위 class 선택자 badges 선택자의 하위 class 선택자 badge 선택자 */
  border-radius: 10px; /* badge 요소의 모서리를 5px 만큼 둥글게 깎는다 */
  overflow: hidden; /* 이미지가 둥글게 깎인 모서리 밖으로 넘치지 않도록 overflow: hidden 값 추가 */
  margin-bottom: 12px; /* 아래쪽 외부 여백: 12px */
  box-shadow: 4px 4px 10px rgba(0,0,0,.15); /* 그림자를 넣기 위해 box-shadow 속성을 이용해서 x축 4px, y축 4px, blur 10px로 설정하고 rgba 함수를 통해서 그림자 색상을 검정색, 투명도는 15%로 설정 */
  cursor: pointer; /* 마우스 포인터를 요소에 올렸을 때 화살표 모양에서 손가락 모양으로 바뀌도록 한다 */
}

/* FOOTER */

footer { /* 'footer' 선택자 */
  background-color: #272727;
  border-top: 1px solid #333; /* 위쪽 테두리선: 1px, 실선, 어두운 회색(#333) */
}
footer .inner { /* 'footer' 선택자의 하위 class 선택자 'inner' */
  padding: 40px 0 60px 0; /* 내부 여백: 위쪽 40px, 오른쪽 0px, 아래쪽: 60px, 왼쪽: 0px */
}
footer .menu { /* 'footer' 선택자의 하위 class 선택자 'menu' */
  display: flex;
  justify-content: center; /* display: flex, justify-content: center 속성을 통해 menu 6개를 수평 가운데로 정렬 */
}
footer .menu li { /* 'footer' 선택자의 하위 class 선택자 'menu'의 하위 선택자 'li' 태그 */
  position: relative;
}
footer .menu li::before { /* 가상 요소 선택자 before를 통해서 선택자 'li' 태그의 내부의 앞쪽에 내용을 삽입 */
  content: "";
  width: 3px;
  height: 3px; /* 너비: 3px, 높이: 3px -> 점 */
  background-color: #555;
  position: absolute; /* position: absoulute 속성을 이용해서 부모 요소 기준으로 배치 */  /* position: absolute 속성을 사용하면 display 값이 자동으로 블록으로 변한다 -> 가로, 세로 값을 가질 수 있다 */ 
  top: 0;
  bottom: 0;
  right: -1px; /* 구조적인 부모 요소(li)를 기준으로 위에서 0px, 아래에서 0px, 오른쪽에서 -1px 지점에 배치 */
  margin: auto; /* 외부 여백(margin)속성을 브라우저가 자동으로 계산하도록 auto로 설정해서 수직 가운데에 맞춘다 -> 위아래 0px 지점에 배치하고 height 값이 있다면 margin: auto를 추기해서 수직 가운데 배치 가능 */
}
footer .menu li:last-child::before { /* 가상 요소 선택자 before 앞에 가상 클래스 선택자 last-child를 추가함으로써 여러 li 태그들 중 마지막 li 태그의 가상 요소 선택자 before 부분 선택 */
  display: none;
}
footer .menu li a { /* 'footer' 선택자의 하위 class 선택자 'menu'의 하위 선택자 'li' 태그의 하위 선택자 'a' 태그 */
  color: #CCC;
  font-size: 12px;
  font-weight: 700; /* 글자 두께: 700 */
  padding: 15px; /* 내부 여백: 15px */
  display: block;  /* a 태그는 원래 인라인 요소이기 때문에 padding을 가질 수 없지만, display: block 속성을 통해 a 태그를 블록 요소로 만들어줘서 가질 수 있도록 한다 */
}
footer .menu li a.green { /* 'footer' 선택자의 하위 class 선택자 'menu'의 하위 선택자 'li' 태그의 하위 선택자 'a & green'(일치 선택자) */
  color: #669900;
}
footer .btn-group { /* 'footer' 선택자의 하위 class 선택자 'bnt-group' */
  margin-top: 20px; /* 위쪽 외부 여백: 20px */
  display: flex;
  justify-content: center; /* display: flex, justify-content: center 속성을 통해 btn 3개를 수평 가운데로 정렬 */
}
footer .btn-group .btn { /* 'footer' 선택자의 하위 class 선택자 'bnt-group'의 하위 class 선택자 'btn' */
  font-size: 12px;
  margin-right: 10px; /* 오른쪽 외부 여백: 10px */
}
footer .btn-group .btn:last-child { /* 가상 클래스 선택자 last-child를 추가함으로써 여러 btn 요소들 중 마지막 btn 요소 선택 */
 margin-right: 0; /* 오른쪽 외부 여백: 0px */
}
footer .info {  /* 'footer' 선택자의 하위 class 선택자 'info' */
  margin-top: 30px; /* 위쪽 외부 여백: 30px */
  text-align: center; /* 글자 정렬: 가운데 */
}
footer .info span {  /* 'footer' 선택자의 하위 class 선택자 'info'의 하위 선택자 span 태그 */ /* span: 인라인 요소이므로 수평으로 쌓이기 때문에(글씨처럼 취급)수평 정렬(display: flex)필요 X */
  margin-right: 20px; /* 오른쪽 외부 여백: 20px */
  color: #999;
  font-size: 12px;
}
footer .info span:last-child { /* 가상 클래스 선택자 last-child를 추가함으로써 여러 span 요소들 중 마지막 span 요소 선택 */
  margin-right: 0; /* 오른쪽 외부 여백: 0px */
}
footer .copyright { /* 'footer' 선택자의 하위 class 선택자 'copyright' */
  color: #999;
  font-size: 12px;
  text-align: center; /* 글자 정렬: 가운데 */
  margin-top: 12px; /* 위쪽 외부 여백: 12px */
}
footer .logo { /* 'footer' 선택자의 하위 class 선택자 'logo' */
  margin: 30px auto 0; /* 외부 여백: 위쪽 30px, 왼쪽/오른쪽 auto, 아래쪽 0px */
}